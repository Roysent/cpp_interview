# 1 网络模型

## 1.1 OSI七层模型

![OSI](./pics/OSI.png)

**”物数网运会表应“**：

（7）应用层：为特定的程序提供数据传输服务，例如HTTP、DNS等协议。数据单位为报文；

（6）表示层：数据压缩、加密以及数据描述，这使得应用程序不用关心各台主机中数据内部格式不同的问题；

（5）会话层：建立及管理会话；

（4）运输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：**传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段**；**用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报**。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

（3）网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层**把传输层传递下来的报文段或者用户数据报封装成分组**。

（2）数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

（1）物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能**屏蔽传输媒体和通信手段的差异**，使数据链路层感觉不到这些差异。

## 1.2 TCP/IP模型

TCP/IP模型只有四层模型，它是将OSI七层模型的上面三层合并为**应用层**，底下两层合并为**网络接口层**。

![TCPIP](./pics/tcpip.png)

## 1.3 数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部；而在向上的过程中不断拆开首部和尾部。

路由器只有**下面三层协议**，因为路由器位于网络核心中，**不需要为进程或者应用程序提供服务**，因此也就不需要传输层和应用层。

# 2 应用层

主要作用：能够写出运行在不同端系统和通过网络彼此通信的程序，而不需要在网络核心设备上（路由器、链路层交换机）运行的软件。

## 2.1 应用程序体系结构

（1）C/S体系结构

（2）P2P体系结构

## 2.2 应用层本质

程序之间的通信本质上是**进程间的通信**，而网络通信实际上就是进程间跨越计算机网络**交换报文**。

套接字（Socket）：进程通过套接字从网络收发报文，所以套接字是进程与计算机网络之间的接口。从网络模型的角度上来说，套接字是应用层与运输层之间的接口。

## 2.3 Web页面请求过程

（1）**DHCP 配置主机信息**

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。
- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。
- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。
- 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。
- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。
- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。
- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

（2）**ARP解析MAC地址**

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。
- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。
- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。
- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。
- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。
- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。
- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

（3）**DNS解析域名**

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

（4）**HTTP请求页面**

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

## 2.4 常用端口

| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |
| ---------------- | ---------- | ------- | ---------- | --------------------------- |
| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |
| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |
| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议     | TELNET     | 23      | TCP        |                             |
| 超文本传送协议   | HTTP       | 80      | TCP        |                             |
| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |
| 邮件读取协议     | POP3       | 110     | TCP        |                             |
| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |



# 3 运输层

运输层提供了进程间的逻辑通信。运输层向高层用户屏蔽了下面网络的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。

TCP和UDP的区别：

（1）传输控制协议（Transmission Control Protocol，TCP）：面向**连接**的，提供**可靠交付**，有流量控制，拥塞控制，提供**全双工通信**，面向**字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是**点对点**的（一对一）。

（2）用户数据报协议（User Datagram Protocol，UDP）：**无连接**的，**尽最大努力交付**，没有拥塞控制，面向**报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

## 3.1 TCP三次握手

TCP首部固定20个字节的长度:

![tcp_head](./pics/tcp_head.png)

（1）源端口和目的端口（16位）：和IP首部的源IP地址和目的IP地址可以唯一确定一个TCP连接；

（２）序号（32位）：表示在这个报文段中第一个数据字节序号；

（3）确认序号（32位）：仅当ACK标志为1时有效，确认号表示期望收到的下一个字节的序号；

（4）偏移（4位）：头部长度；

（6）保留（6位），必须为0；

（7）6个标志位（各1位）：

- URG-紧急指针有效；
- ACK-确认序号有效；
- PSH-接收方应尽快将这个报文交给应用层；
- RST-连接重置；
- SYN-同步序号用来发起一个连接；
- FIN-终止一个连接。

（8）窗口字段（16位）：代表窗口的字节容量，标准大小为2^16-1=65535个字节；

（9）包校验和（16位）：机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。

### 3.1.1 过程

为了保证数据传输成功，TCP采用三次握手策略：

<img src="./pics/tcp3.png" alt="tcp3" style="zoom:50%;" />

（1）客户端向服务器发送**连接请求报文**段，SYN=1，序号seq=x，此时客户端进入**SYN-SENT**（同步已发送）状态。

【**第一次的seq序列号x是随机产生的**，这样是为了**网络安全**。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间的初始化序列号，并且伪造序列号进行攻击】

（2）服务器收到连接请求报文，如果同意建立连接，则向客户端发送**连接确认报文段**，SYN=1，ACK=1，确认序号为ack=x+1，自己的序号seq=y，服务器进入SYN-RCVD（**同步已收到**）状态

【**SYN 是为了告诉发送端，发送方到接收方的通道没问题**；**ACK 用来验证接收方到发送方的通道没问题**】

（3）客户端收到服务器的连接确认报文后，还要向服务器**发出确认**，ACK=1，确认号为ack=y+1，自己的序号为seq=x+1，然后客户端进入**ESTABLISHED**（已建立连接）状态。

【最后一次确认是为了防止已经失效的连接请求报文段又传回到了服务端，从而产生错误】

（TCP规定，SYN报文段（SYN= 1）不能携带数据，但是会**消耗一个序号**，而ACK报文段**可以携带数据，但不携带数据就不消耗序号**）

### 3.1.2 为什么要进行三次握手？

TCP进行三次握手的原因是让通信双方确认**自己和对方的发送和接收**是正常的，建立可靠的通信信道。

### 3.1.3 为什么要进行第三次握手？

防止**已经失效的连接请求报文**又突然传送到了服务器，从而产生错误。

如何只有两次握手，可能会出现以下情况：

- 客户端发送了第一个请求连接并且没有丢失，但由于网络原因在节点中滞留。
- 由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。 
- 此时此前滞留的那一次请求连接，网络通畅了到达服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 
- 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 3.1.4 最后一次握手丢失会发生什么？

- 如果最后一次ACK在网络中丢失，那么**服务端该TCP连接的状态仍为SYN_RECV**，并且根据 TCP的**超时重传机制**依次等待3秒、6秒、12秒后重新发送 SYN+ACK 包，默认重复5次，以便 **客户端重新发送ACK包** 
- 如果重发指定次数后，**仍然未收到ACK应答**，那么一段时间后，**服务端自动关闭这个连接** 
- 但是客户端认为这个连接已经建立，如果客户端端向服务端发送数据，**服务端将以RST包（Reset，RST标示复位，用于异常的关闭连接）响应**，此时，**客户端知道第三次握手失败**

### 3.1.5 SYN洪泛攻击是什么？

SYN洪泛（SYN Flood）攻击，利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的**请求连接的第一个握手包（SYN包）**，被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。**导致被攻击服务器保持大量SYN_RECV状态的“半连接”**，并且会重试默认5次回应第二个握手包，**大量随机的恶意SYN占满了未完成连接队列，导致正常合法的SYN排不上队列，让正常的业务请求连接不进来**。【服务器端的资源分配是在**二次握手时分配**的，而客户端的资源是在完成**三次握手时分配**的，所以服务器容易受到SYN洪泛攻击】

解决方法:

- 缩短超时重传时间（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

1. **当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源**，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数**生成一个 cookie，并把 cookie 作为序列号响应给客户端**。 
2. **如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段**。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，**如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源**

### 3.1.6 TCP握手后，客户端掉线了服务器知道吗？

三次握手完成后，若客户端掉线了，由于**保活机制**在连接后会隔一段时间发送一个**保活探测报文**，超过保活探测次数的话服务器就会知道，然后就及时关闭连接。

如果短时间内客户端重新上线，若双方都没有释放连接的话，则不需要重新握手。

## 3.2 TCP四次挥手

### 3.2.1 过程

<img src="D:\Desktop\PlanBrick\CPP\interview\pics\tcp4.jpg" style="zoom:50%;" />

（1）A发送连接释放报文段FIN=1，seq=u，并停止再发送数据，主动关闭TCP的连接，此时A进入终止等待１（FIN－WAIT－１）状态，等待B的确认；

（2）B收到这个FIN，发回一 个ACK确认报文ACK=1，seq=v，ack=u+1，确认序号为收到的序号加1（和 SYN 一样，一个 FIN 将占用一个序号），此时B进入关闭等待（CLOSE-WAIT）状态。此时 TCP 属于半关闭状态，A没有数据要发送了，但是若B发送数据A任然要接收。A收到来自B的确认后，进入终止等待２（FIN－WAIT-2）状态，等待B发送连接释放报文段；

（3）当B不需要发送数据时，发送一个连接释放报文段FIN=1，ACK=1，seq=w，ack=u+1，此时B进入最后确认状态（LAST-ACK），等待A的确认；

（4）A收到B的连接释放报文段后，回复确认报文段ACK=1，ack=w+1，seq=u+1，B收到回复后进入CLOSED状态，撤销相应的PCB后撤销TCP连接。而A进入到TIME-WAIT（时间等待）状态，等待２MSL（Maximum Segment Lifetime，最长报文段寿命）后进入CLOSED状态，撤销相应的传输控制块PCB后，结束本次TCP连接。

### 3.2.2 为什么挥手要四次？

建立连接的时候，服务器在LISTEN状态下收到客户端的SYN连接请求报文段后，是将SYN和ACK放在一个报文中发送给（第二次握手）客户端的。

关闭连接时，服务器收到对方的连接释放报文段后，只是代表客户端不会再发送数据了（任然能接收数据），而服务器可以选择立即关闭，也可以选择继续发送数据，所以是将ACK和FIN分开发送，从而导致多了一次。

### 3.2.3 为什么要有一个FIN-WAIT-2状态？

A接收到B的确认后（第二次挥手后），就进入到了FIN-WAIT-2状态。如果这个时候因为网络突然断掉、服务器宕机等原因导致A无法收到B的FIN报文段，这个时候就需要FIN-WAIT-2定时器。定时器超时后A还未收到B的FIN的话，就直接进入CLOSE状态，减少资源占用。

### 3.2.3 为什么最后要等2MSL？

（1）为了保证A发送的最后一个ACK能够到达B。如果处在LAST-ACK状态的B在没有收到A的ACK报文段的话，B会超时重传FIN报文段（重新第三次挥手），若A能在2MSL的时间内收到FIN报文段，A就会重传最后一次ACK报文段，并重启2MSL计时器，使得A和B都能成功进入CLOSEＤ状态。如果不等的话，A直接进入CLOSEＤ，万一B没有收到确认，就无法进入CLOSEＤ状态

（２）防止“已经失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过２MSL，就可以使本连接持续的时间内所产生的所有报文段从网络中消失。这样就可以使下一个连接中不会出现旧的连接请求报文段。

### 3.2.4 TIME-WAIT状态的连接过多产生什么后果，怎么处理？

后果：

（1）对于服务器来说，短时间内关闭了大量的客户端连接，就会造成服务器上出现大量的TIME_WAIT连接，**占据大量的tuple ，严重消耗着服务器的资源**，此时部分客户端就会显示连接不上 

（2）对于客户端来说，短时间内大量的短连接，会大量**消耗端口**，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了 

解决方法：

（1）用**负载均衡**来抗这些高并发的短请求。

（2）服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，TIME_WAIT 状态可以通过**优化服务器参数**得到解决，因为发生TIME-WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。

（3）强制关闭，发送 RST 包越过TIME-WAIT状态，直接进入CLOSED状态。

### 3.2.5 服务端会有TIME-WAIT状态吗？

一般来说，**主动撤销连接**的都会进入到TIME-WAIT状态。

## 3.3 TCP传输控制

### 3.3.1 TCP可靠传输原理

TCP 使用**确认和超时重传机制**来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

上面的机制通常称为**自动请求重传ARQ**（Automatic Repeat reQuest）。

### 3.3.2 TCP流量控制

流量控制是为了**控制发送方发送速率**，保证接收方**来得及接收**。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 3.3.3 TCP拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了**降低整个网络的拥塞程度**。

（1）**慢开始**与**拥塞避免**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

（2）**快重传**与**快恢复**

在接收方，要求每次接收到报文段都应该对**最后一个已收到的有序报文段进行确认**。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

<img src="./pics/kcc.png" alt="kcc" style="zoom:50%;" />

## 3.4 UDP协议

UDP协议对应用层交下来的报文，既不合并也不拆分，而是保留这些报文的边界，添加首部后，就直接传输。

用户数据报UDP有两个字段，数据字段和首部字段。首部字段只有8个字节长度：

（1）源端口：

（2）目的端口：

（3）长度：数据报的长度。最小长度为８。

（4）校验和：检测UDP用户数据报在传输中是否有错。

如果接收方UDP发现收到的报文中的目的端口号不正确，就丢弃该报文，并由**网际控制报文协议ICMP发送“端口不可达”差错报**给发送方。

## 3.5 RTMP协议

RTMP（Real Time Messaging Protocol） 是由 Adobe 公司基于 Flash Player 播放器对应的音视频 flv 封装格式提出的一种，基于TCP 的数据传输协议。本身具有稳定、兼容性强、高穿透的特点。常被应用于流媒体直播、点播等场景。常用于推流方（主播）的稳定传输需求。

# 4 网络层

# 6 物理层

本层上进行比特率的传输，详细地说就是模拟信号和数字信号的传输。