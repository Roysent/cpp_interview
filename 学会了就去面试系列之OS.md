# 操作系统

## 1 进程和线程

### 1.1 定义

进程：正在执行的**程序的实例**，是**资源分配的基本单位**，实现了操作系统的并发。

线程：是进程的**子任务**，是**独立调度的基本单位**，是操作系统可识别的最小执行和调度单位，用于保证程序的实时性，实现进程内部的并发。每个线程都独自占用一个虚拟处理器。每个线程的任务都不相同，但是共享同一地址空间。

### 1.2 区别

（1）一个线程只能属于一个进程，而一个进程可以有多个线程但最少有一个线程。线程依赖于进程而存在。

（2） 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） 

（3）进程是资源分配的最小单位，线程是独立调度的最小单位。

（4）在创建和撤销进程时，系统都要为之分配或回收内存、I/O等资源，而线程只需要保存和设置少量寄存器和栈段的内容，并不涉及存储器管理方面的操作，因此进程切换的开销远大于线程切换。

（5）进程之间不会相互影响，但是一个线程挂掉会导致整个进程挂掉。

为啥要引入线程？

进程可以使多个程序能并发执行，以提高**资源的利用率**和系统的**吞吐量**；但是其具有一些缺点：进程在同一时间只能干一件事，进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。因此，操作系统引入了比进程粒度更小的线程，**作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。**

和进程相比，线程的优势如下：

（1） 从**资源**上来讲，线程是一种非常"节俭"的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。 

（2） 从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。 

（3） 从**通信机制**上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。 

## 2 进程

### 2.1 状态

ready：就绪状态

running：运行状态

waiting：等待资源

（1）ready和running状态可以互相转换，其中ready->running这一过程是通过**进程间的调度算法**实现的；running->ready是进程**消耗完分配的CPU时间片**自动转换的。

（2）waiting状态是running状态缺少必要的资源转换过来的，但是该资源不包括CPU时间片，缺少时间片会转换为ready状态。

### 2.1 进程调度算法

（1）批处理系统：调度算法的目的是**保证吞吐量和周转时间**

**先来先服务（First Come First Served）**：非抢占式的调度算法，按照请求的先后顺序。

**短任务优先（Shortest Job First）：**非抢占式算法，按照估计运行时间最短优先的原则调度。

**最短剩余时间优先（Shortest Remaining Time Next）**：抢占式算法，按照最短剩余时间原则进行调度，如果新任务的时间更短，则当前进程挂起，运行新的进程。

（2）交互式系统：调度算法的目的是快速地进行响应

**时间片轮转调度算法**： 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 

缺点：时间片太小，进程频繁切换降低效率；时间片太大，实时性无法保证。

**优先级调度算法**：为每个进程分配一个优先级，按优先级进行调度。同时为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**多级反馈队列**： 时间片轮转调度算法和优先级调度算法的结合。 设置多个队列，每个队列的时间片长度不一样，优先级也不一样，进程在第一个队列中没执行完会被移到下一个队列中，以此减少交换次数。

### 2.2 进程同步

临界区：访问临界资源的代码。

同步：多个进程由于**合作产生制约关系**，使得进程的执行有一定的先后顺序。

互斥：多个进程同一时刻只能有一个进程进入临界区。

### 2.3 进程间通信

进程间通信方式主要包括管道（PIEP）、系统IPC（消息队列、信号量、共享内存等）、以及套接字socket。

（1）管道

有名管道：半双工通信方式，允许无亲缘关系进程间的通信。

​				优点：可以实现任意关系进程间的通信。

​				缺点：长期存在于系统之中，使用不当容易出错；缓冲区有限。

无名管道：半双工通信方式，只允许有亲缘关系的进程间使用。

​				优点：简单方便。

​				缺点：局限于单向通信，只能创建在它的进程以及有亲缘关系的进程间使用；缓冲区有限。

（2）信号量

一个计数器，可以用来控制多个线程对**共享资源**的访问。

​				优点：可以同步进程。

​				缺点：信号量有限

（3）消息队列

是消息的链表，存放在内核中并由消息队列标识符标志。

​				优点：可以实现任意进程之间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便。

​				缺点：信息的复制需要耗费CPU的时间，不适宜于信息量大或操作频繁的场合。

（4）共享内存

映射一段能够被其它进程访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

​				优点：无需复制，快捷，信息量大。

​				缺点：通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此会带来进程间读写操作的同步问题；利用内存缓冲区之间交换信息，内存的实体存在于计算机中，只能同一个计算机词统中的诸多进程共享，不方便网络通信。

（5）套接字socket

可用不同计算机之间的进程通信。

## 3 死锁

### 3.1 含义

死锁是指两个或两个以上的进程在执行过程中，由于**竞争资源或者由于彼此通信而造成的一种互相等待**的现象，若无外力作用，它们都将无法推进下去。此时称系统产生了死锁或系统处于死锁状态，这些永远在互相等待的进程称为死锁进程。 

产生原因：系统资源不足、资源分配不当、进程运行推进顺序不合适

### 3.2 必要条件

（1）互斥：每个资源要么已经分配给了一个进程，要么就是可用的。

（2）占有和等待：已经得到了某个资源的进程可以再请求新的资源。

（3）不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。

（4）环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

### 3.3 处理方法

（1）鸵鸟策略：不理会死锁，直接忽略。

（2）死锁检测与死锁恢复：不试图阻止死锁，而是检测到死锁发生时，采取措施进行恢复。

​		死锁恢复：利用抢占恢复，利用回滚恢复，通过杀死进程恢复。

（3）死锁预防：在程序运行之前预防发生死锁。

​		a. 破环互斥条件

​		b.破坏和占有等待条件

​		c.破坏不可抢占条件

​		d.破坏环路等待

（4）死锁避免：在程序运行时避免发生死锁。

安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也任然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。（银行家算法）

a.避免嵌套锁：

 一个线程已获得一个锁时，再别去获取第二个。因为每个线程只持有一个锁，锁上就不会产生死锁。即使互斥锁造成死锁的最常见原因，也可能会在其他方面受到死锁的困扰(比如：线程间的互相等待)。当你需要获取多个锁，使用一个`std::lock`来做这件事(对获取锁的操作上锁)，避免产生死锁。 

b.避免在持有锁时调用用户提供的代码：

 因为代码是用户提供的，你没有办法确定用户要做什么；用户程序可能做任何事情，包括获取锁。你在持有锁的情况下，调用用户提供的代码；如果用户代码要获取一个锁，就会违反第一个指导意见，并造成死锁(有时，这是无法避免的)。 

c.使用固定顺序获取锁

 当硬性条件要求你获取两个或两个以上的锁，并且不能使用`std::lock`单独操作来获取它们；那么最好在每个线程上，用固定的顺序获取它们(锁)。3.2.4节中提到，当需要获取两个互斥量时，避免死锁的方法，关键是如何在线程之间，以一定的顺序获取锁。 

d.使用锁的层次结构

 虽然，定义锁的顺序是一种特殊情况，但锁的层次的意义在于提供对运行时约定是否被坚持的检查。这个建议需要对你的应用进行分层，并且识别在给定层上所有可上锁的互斥量。当代码试图对一个互斥量上锁，在该层锁已被低层持有时，上锁是不允许的。你可以在运行时对其进行检查，通过分配层数到每个互斥量上，以及记录被每个线程上锁的互斥量。 

## 4 内存管理

### 4.1 虚拟内存

虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）。而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

为了更好的管理内存，操作系统将内存(RAM)抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

虚拟内存的目的是让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

优点：

（1）虚拟内存地址空间是连续的，没有碎片。

（2）虚拟内存的最大空间就是CPU的最大寻址空间，不受内存大小的限制，能提供比内存更大的地址空间

### 4.2 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page Table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分：一部分存储页面号，一部分存储偏移量。

### 4.3 页面置换算法（分页）

（1）最佳置换算法（Optimal Replacement Algorithm）

所选择被置换出来的是最长时间内不再被访问的页面，通常可以保证最低的缺页率。理论最优算法。

（2）最近最久未使用（Least Recently Used）

将最近最久未使用的页面换出。维护一个记录最近访问过的页面链表，新访问的放在表头，这样表尾就是最近最久未访问的页面。

（5）最近未使用（Not Recently Used）

 每个页面都有两个**状态位**：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。所以根据R和M位可以将页面分成四类。当发生缺页中断时，NRU算法换出已经被修改的脏页面（R=0,M=1），而不是被频繁使用的干净页面（R=1,M=0） 

（4）先进先出（First In First Out）

将最先进入的页面换出。缺点是容易将经常被访问的页面换出，导致缺页率升高。

（5）第二次机会算法（Second Chance Algorithm）

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

（6）时钟（Clock）算法

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

### 4.4 分段

虚拟内存采用的是分页技术，将地址空间划分成固定大小的页，每一页与内存进行映射。

编译器在编译过程中建立多个表，有些表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题。

分段的做法是把每个表分成段，一个段构成一个独立的地址空间，每个段的长度可以不同，并且可以动态增长。

**分页和分段对比：**

|      | 透明性   | 地址空间维度 | 大小               | 目的                                                         |
| ---- | -------- | ------------ | ------------------ | ------------------------------------------------------------ |
| 分页 | 透明     | 一维地址空间 | 页大小不可变       | 用于虚拟内存，为了获取更大的地址空间                         |
| 分段 | 显示划分 | 二维地址空间 | 段大小可以动态改变 | 为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护 |

### 4.5 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。













## 3 线程

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 3.1 锁机制

（1）互斥锁（mutex）：提供了以排他方式防止数据结构被并发修改的方法。

（2）读写锁（Read-Write Lock）：允许多个线程同时共享数据，而对写操作是互斥的。

（3）自旋锁（spin lock）：与互斥锁类似，都是为了保护共享资源。互斥锁是当前资源被占用，申请者进入休眠状态；而自旋锁则循环检测保持者是否已经释放锁。

（4）条件变量（condition）：可以以原子的方式阻塞进程，直到某个条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

### 3.2 信号量机制

（1）无名线程信号量

（2）命名线程信号量

### 3.3 信号机制

类似进程间的信号处理

### 3.4 屏蔽

 屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。 

## 4 面经总结

### 4.1 Linux指令

ps：查看系统进程

ps -ef：查看所有进程

kill -9：强制关掉进程

kill -15：系统通知进程让其主动关闭进程

ulimit -a ：查看打开文件配置

### 4.2 用户态和内核态

内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。

用户态的应用程序可以通过三种方式来访问内核态的资源：

- 系统调用
- 库函数
- shell脚本

用户态到内核态的切换：

- 系统调用
- 外设中断
- 异常

